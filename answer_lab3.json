{"_id":{"$oid":"5f6a474639a55b1b090be0ff"},"1.1":{"_batch":[{"_id":null,"Количество":1.0},{"_id":"Экстернат","Количество":18.0},{"_id":"Заочная","Количество":5817.0},{"_id":"Очная","Количество":55849.0},{"_id":"Очно-заочная","Количество":7645.0}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Students","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Students","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a475839a55b1b090be100"},"1.2":{"_batch":[{"_id":"Физико-математических  и естественных наук","Количество":1735.0},{"_id":"Учебно-научный институт гравитации и космологии","Количество":30.0},{"_id":"Институт иностранных языков","Количество":1130.0},{"_id":"Аграрный","Количество":1731.0},{"_id":"Институт гостиничного бизнеса и туризма","Количество":914.0},{"_id":"Юридический","Количество":3613.0},{"_id":"Филологический","Количество":4449.0},{"_id":"Инженерный","Количество":4202.0},{"_id":"Экономический","Количество":4092.0},{"_id":"Курчатовский Институт","Количество":10.0},{"_id":"Институт мировой экономики и бизнеса","Количество":1168.0},{"_id":"Институт прикладных технико-экономических исследований и экспертиз","Количество":66.0},{"_id":"Экологический","Количество":989.0},{"_id":"Медицинский","Количество":4361.0},{"_id":"Гуманитарных и социальных наук","Количество":4917.0},{"_id":"Институт международных программ","Количество":38.0},{"_id":"Кафедра сравнительной образовательной политики","Количество":92.0}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Students","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Students","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a476e39a55b1b090be101"},"1.3":{"_batch":[],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Students","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Students","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a478039a55b1b090be102"},"1.4":{"_batch":[],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Students","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Students","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a478e39a55b1b090be103"},"1.5":{"_batch":[{"_id":"Физико-математических  и естественных наук","Значение":1},{"_id":"Учебно-научный институт гравитации и космологии","Значение":1},{"_id":"Институт иностранных языков","Значение":1},{"_id":"Аграрный","Значение":1},{"_id":"Институт гостиничного бизнеса и туризма","Значение":1},{"_id":"Юридический","Значение":1},{"_id":"Филологический","Значение":1},{"_id":"Экономический","Значение":1},{"_id":"Инженерный","Значение":1},{"_id":"Курчатовский Институт","Значение":1},{"_id":"Институт мировой экономики и бизнеса","Значение":1},{"_id":"Институт прикладных технико-экономических исследований и экспертиз","Значение":1},{"_id":"Экологический","Значение":1},{"_id":"Научно-образовательный центр Нанотехнологии","Значение":1},{"_id":"Медицинский","Значение":1},{"_id":"Кафедра сравнительной образовательной политики","Значение":1},{"_id":"Институт международных программ","Значение":1},{"_id":"Гуманитарных и социальных наук","Значение":1}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Students","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Students","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a47a039a55b1b090be104"},"2.1":{"_batch":[{"_id":"русский","Количество":62417.0}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Students2","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Students2","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a47b439a55b1b090be105"},"2.1.2":{"_batch":[{"_id":"русский","Количество":30263.0}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Students2","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Students2","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a47d539a55b1b090be106"},"2.2":{"_batch":[{"_id":"испанский","Количество":6942.0},{"_id":"английский","Количество":48491.0},{"_id":"французский","Количество":20757.0},{"_id":"немецкий","Количество":34647.0},{"_id":"русский","Количество":62417.0}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Students2","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Students2","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a47ef39a55b1b090be107"},"2.3":{"_batch":[{"_id":"испанский","Количество":1617.0},{"_id":"английский","Количество":11313.0},{"_id":"французский","Количество":4845.0},{"_id":"немецкий","Количество":8085.0},{"_id":"русский","Количество":14569.0}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Students2","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Students2","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a480239a55b1b090be108"},"3.1":{"_batch":[{"_id":{"$oid":"5f6a358a5deb04f9c56a5ef1"},"Номер":"1032074056","Статус":"Отчисление","Гражданство":"Республика Грузия","Пол":"Женский","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий"]},{"_id":{"$oid":"5f6a358a5deb04f9c56a5eef"},"Номер":"1032074055","Статус":"Отчисление","Гражданство":"Республика Грузия","Пол":"Женский","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий"]},{"_id":{"$oid":"5f6a358a5deb04f9c56a5e6e"},"Номер":"1032114862","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский"]},{"_id":{"$oid":"5f6a358a5deb04f9c56a579e"},"Номер":"1032110680","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Менеджмент","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4},{"_id":{"$oid":"5f6a358a5deb04f9c56a4ed8"},"Номер":"1032081640","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Менеджмент","Форма обучения":"Заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4},{"_id":{"$oid":"5f6a358a5deb04f9c56a4e7d"},"Номер":"1032090929","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Женский","Факультет":"Экономический","Специальность":"Маркетинг","Форма обучения":"Очная","Уровень":"Специальность","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий","французский","испанский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a47dd"},"Номер":"1032114971","Статус":"Отчисление","Гражданство":"Республика Казахстан","Пол":"Женский","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a463b"},"Номер":"1032115677","Статус":"Отчисление","Гражданство":"Республика Казахстан","Пол":"Мужской","Факультет":"Экономический","Специальность":"Менеджмент","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"бюджет","Курс":4,"Languages":["русский","английский","немецкий","французский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a4282"},"Номер":"1032112599","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Женский","Факультет":"Экономический","Специальность":"Менеджмент","Форма обучения":"Заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий","французский","испанский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a4213"},"Номер":"1032054361","Статус":"Отчисление","Гражданство":"Китай","Пол":"Мужской","Факультет":"Экономический","Специальность":"Менеджмент","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a4060"},"Номер":"1032112770","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4},{"_id":{"$oid":"5f6a35895deb04f9c56a3d91"},"Номер":"1032075058","Статус":"Отчисление","Гражданство":"Кыргызская Республика","Пол":"Мужской","Факультет":"Экономический","Специальность":"Маркетинг","Форма обучения":"Очная","Уровень":"Специальность","Период":"Полный","Финансирование":"бюджет","Курс":4,"Languages":["русский","английский","немецкий","французский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a34d4"},"Номер":"1032103081","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Женский","Факультет":"Экономический","Специальность":"Менеджмент","Форма обучения":"Очно-заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a345d"},"Номер":"1032011017","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"бюджет","Курс":4,"Languages":["русский","английский","немецкий","французский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a3235"},"Номер":"1032031181","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Маркетинг","Форма обучения":"Очная","Уровень":"Специальность","Период":"Полный","Финансирование":"бюджет","Курс":4,"Languages":["русский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a3217"},"Номер":"1032110408","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Женский","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий","французский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a3140"},"Номер":"1032091991","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Женский","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a300d"},"Номер":"1032100952","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Менеджмент","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский"]},{"_id":{"$oid":"5f6a35895deb04f9c56a2e46"},"Номер":"1032082488","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Женский","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очно-заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий","французский"]},{"_id":{"$oid":"5f6a35885deb04f9c56a2883"},"Номер":"1032094110","Статус":"Отчисление","Гражданство":"Азербайджанская Республика","Пол":"Мужской","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4},{"_id":{"$oid":"5f6a35885deb04f9c56a23a6"},"Номер":"1032055205","Статус":"Отчисление","Гражданство":"Республика Эквадор","Пол":"Мужской","Факультет":"Экономический","Специальность":"Менеджмент","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий"]},{"_id":{"$oid":"5f6a35885deb04f9c56a2251"},"Номер":"1032060383","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Женский","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очно-заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский"]},{"_id":{"$oid":"5f6a35885deb04f9c56a197e"},"Номер":"1032083371","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский"]},{"_id":{"$oid":"5f6a35885deb04f9c56a18e3"},"Номер":"1032021455","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Женский","Факультет":"Экономический","Специальность":"Маркетинг","Форма обучения":"Очная","Уровень":"Специальность","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий"]},{"_id":{"$oid":"5f6a35885deb04f9c56a15a0"},"Номер":"1032101472","Статус":"Отчисление","Гражданство":"Республика Беларусь","Пол":"Женский","Факультет":"Экономический","Специальность":"Менеджмент","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"бюджет","Курс":4,"Languages":["русский"]},{"_id":{"$oid":"5f6a35885deb04f9c56a104e"},"Номер":"1032032413","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Женский","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский"]},{"_id":{"$oid":"5f6a35885deb04f9c56a0f45"},"Номер":"1032011001","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"бюджет","Курс":4,"Languages":["русский"]},{"_id":{"$oid":"5f6a35885deb04f9c56a0dde"},"Номер":"1032034357","Статус":"Отчисление","Гражданство":"Китай","Пол":"Женский","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"бюджет","Курс":4,"Languages":["русский","английский","немецкий","французский"]},{"_id":{"$oid":"5f6a35885deb04f9c56a0cf8"},"Номер":"1032072703","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский"]},{"_id":{"$oid":"5f6a35885deb04f9c56a0b86"},"Номер":"1032111918","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий","французский"]},{"_id":{"$oid":"5f6a35885deb04f9c56a0a95"},"Номер":"1032082870","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Женский","Факультет":"Экономический","Специальность":"Финансы и кредит","Форма обучения":"Очная","Уровень":"Специальность","Период":"Полный","Финансирование":"контракт","Курс":4},{"_id":{"$oid":"5f6a35885deb04f9c56a0989"},"Номер":"1032110689","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий","французский","испанский"]},{"_id":{"$oid":"5f6a35875deb04f9c569f917"},"Номер":"1032104196","Статус":"Отчисление","Гражданство":"Республика Узбекистан","Пол":"Мужской","Факультет":"Экономический","Специальность":"Менеджмент","Форма обучения":"Очно-заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий"]},{"_id":{"$oid":"5f6a35875deb04f9c569f8ba"},"Номер":"1032073411","Статус":"Отчисление","Гражданство":"Российская Федерация","Пол":"Мужской","Факультет":"Экономический","Специальность":"Экономика","Форма обучения":"Очно-заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский"]},{"_id":{"$oid":"5f6a35875deb04f9c569f7e8"},"Номер":"1032084415","Статус":"Отчисление","Гражданство":"Азербайджанская Республика","Пол":"Женский","Факультет":"Экономический","Специальность":"Менеджмент","Форма обучения":"Заочная","Уровень":"Бакалавриат","Период":"Полный","Финансирование":"контракт","Курс":4,"Languages":["русский","английский","немецкий"]}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Students2","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Students2","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a485e39a55b1b090be109"},"Lab3.2 1.1":{"_batch":[],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Task2","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Task2","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a486d39a55b1b090be10a"},"Lab3.2 1.2":{"_batch":[{"_id":{"_id":"1001","type":"Regular"},"Количество":3.0}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Task2","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Task2","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a487939a55b1b090be10b"},"Lab3.2 1.3":{"_batch":[{"_id":"OldFashioned","Количество":4.0},{"_id":"Raised","Количество":5.0},{"_id":"Cake","Количество":7.0}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Task2","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Task2","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a488439a55b1b090be10c"},"Lab3.2 1.4":{"_batch":[{"_id":"OldFashioned","Количество":2.0},{"_id":"Raised","Количество":1.0},{"_id":"Cake","Количество":4.0}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Task2","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Task2","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a489639a55b1b090be10d"},"Lab3.3 1":{"_batch":[{"_id":{"$oid":"5f6a413f0931971fee54f41d"},"ID":306967,"Surname":"Школа","PeoplesCount":73000000}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Surnames","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Surnames","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a48a039a55b1b090be10e"},"Lab3.3 2":{"_batch":[{"Surname":"Нгуен","PeoplesCount":4000}],"_useReadCommands":true,"_cursorid":0,"_batchSize":{"$undefined":true},"_maxAwaitTimeMS":{"$undefined":true},"_txnNumber":{"$undefined":true},"_ns":"lab3.Surnames","_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"getClient":{"$code":"function() {\n            return client;\n        }"},"_getSessionAwareClient":{"$code":"function() {\n            return sessionAwareClient;\n        }"},"getDatabase":{"$code":"function(dbName) {\n            const db = client.getDB(dbName);\n            db._session = this;\n            return db;\n        }"}}},"_collName":"Surnames","_cursorHandle":{}}}
{"_id":{"$oid":"5f6a48ab39a55b1b090be10f"},"Lab3.3 3":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}}},"_collection":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}}},"_shortName":"Surnames","_fullName":"lab3.Surnames"},"_ns":"lab3.Surnames","_query":{"PeoplesCount":{"$gte":4000.0}},"_fields":null,"_limit":0.0,"_skip":0.0,"_batchSize":0.0,"_options":0.0,"_cursor":null,"_numReturned":0.0,"_special":false}}
{"_id":{"$oid":"5f6a48ba39a55b1b090be110"},"Lab3.3 4":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}}},"_collection":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_db":{"_mongo":{"slaveOk":false,"host":"127.0.0.1:27017","defaultDB":"test","_defaultSession":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}},"_readMode":"commands","promptPrefix":"","authStatus":{"authRequired":true,"replSetGetStatus":false,"isMaster":true},"_writeMode":"commands"},"_name":"lab3","_session":{"_serverSession":{"handle":{},"isTxnActive":{"$code":"function isTxnActive() {\n            return hasTxnState(\"active\");\n        }"},"isFirstStatement":{"$code":"function isFirstStatement() {\n            return _nextStatementId === 0;\n        }"},"getLastUsed":{"$code":"function getLastUsed() {\n            return _lastUsed;\n        }"},"getTxnNumber":{"$code":"function getTxnNumber() {\n            return this.handle.getTxnNumber();\n        }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n            this.handle.setTxnNumber(newTxnNumber);\n        }"},"getTxnOptions":{"$code":"function getTxnOptions() {\n            return _txnOptions;\n        }"},"injectSessionId":{"$code":"function injectSessionId(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"lsid\")) {\n                if (isAcknowledged(cmdObjUnwrapped)) {\n                    cmdObjUnwrapped.lsid = this.handle.getId();\n                }\n\n                // We consider the session to still be in use by the client any time the session id\n                // is injected into the command object as part of making a request.\n                updateLastUsed();\n            }\n\n            return cmdObj;\n        }"},"assignTransactionNumber":{"$code":"function assignTransactionNumber(cmdObj) {\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                this.handle.incrementTxnNumber();\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            return cmdObj;\n        }"},"assignTxnInfo":{"$code":"function assignTxnInfo(cmdObj) {\n            // We will want to reset the transaction state to 'inactive' if a normal operation\n            // follows a committed or aborted transaction.\n            if ((hasTxnState(\"aborted\")) ||\n                (hasTxnState(\"committed\") && Object.keys(cmdObj)[0] !== \"commitTransaction\")) {\n                setTxnState(\"inactive\");\n            }\n\n            // If we're not in an active transaction or performing a retry on commitTransaction,\n            // return early.\n            if (hasTxnState(\"inactive\")) {\n                return cmdObj;\n            }\n\n            // If we reconnect to a 3.6 server in the middle of a transaction, we\n            // catch it here.\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                setTxnState(\"inactive\");\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            cmdObj = Object.assign({}, cmdObj);\n\n            const cmdName = Object.keys(cmdObj)[0];\n\n            // If the command is in a wrapped form, then we look for the actual command object\n            // inside the query/$query object.\n            let cmdObjUnwrapped = cmdObj;\n            if (cmdName === \"query\" || cmdName === \"$query\") {\n                cmdObj[cmdName] = Object.assign({}, cmdObj[cmdName]);\n                cmdObjUnwrapped = cmdObj[cmdName];\n            }\n\n            if (!cmdObjUnwrapped.hasOwnProperty(\"txnNumber\")) {\n                cmdObjUnwrapped.txnNumber = this.handle.getTxnNumber();\n            }\n\n            // All operations of a multi-statement transaction must specify autocommit=false.\n            cmdObjUnwrapped.autocommit = false;\n\n            // Statement Id is required on all transaction operations.\n            cmdObjUnwrapped.stmtId = new NumberInt(_nextStatementId);\n\n            // 'readConcern' and 'startTransaction' can only be specified on the first statement\n            // in a transaction.\n            if (_nextStatementId == 0) {\n                cmdObjUnwrapped.startTransaction = true;\n                if (_txnOptions.getTxnReadConcern() !== undefined) {\n                    // Override the readConcern with the one specified during startTransaction.\n                    cmdObjUnwrapped.readConcern = Object.assign(\n                        {}, cmdObjUnwrapped.readConcern, _txnOptions.getTxnReadConcern());\n                }\n            }\n\n            // Reserve the statement ids for batch writes.\n            switch (cmdName) {\n                case \"insert\":\n                    _nextStatementId += cmdObjUnwrapped.documents.length;\n                    break;\n                case \"update\":\n                    _nextStatementId += cmdObjUnwrapped.updates.length;\n                    break;\n                case \"delete\":\n                    _nextStatementId += cmdObjUnwrapped.deletes.length;\n                    break;\n                default:\n                    _nextStatementId += 1;\n            }\n\n            return cmdObj;\n        }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj, ignoreActiveTxn) {\n            // If the session is already in a transaction, raise an error. If ignoreActiveTxn\n            // is true, don't raise an error. This is to allow multiple threads to try to\n            // use the same session in a concurrency workload.\n            if (this.isTxnActive() && !ignoreActiveTxn) {\n                throw new Error(\"Transaction already in progress on this session.\");\n            }\n            if (!serverSupports(kWireVersionSupportingMultiDocumentTransactions)) {\n                throw new Error(\n                    \"Transactions are only supported on server versions 4.0 and greater.\");\n            }\n            _txnOptions = new TransactionOptions(txnOptsObj);\n            setTxnState(\"active\");\n            _nextStatementId = 0;\n            this.handle.incrementTxnNumber();\n        }"},"commitTransaction":{"$code":"function commitTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to commit it.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call commitTransaction after calling abortTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to commit on this session.\");\n            }\n            // run commitTxn command\n            return endTransaction(\"commitTransaction\", driverSession);\n        }"},"abortTransaction":{"$code":"function abortTransaction(driverSession) {\n            // If the transaction state is already 'aborted' we cannot try to abort it again.\n            if (hasTxnState(\"aborted\")) {\n                throw new Error(\"Cannot call abortTransaction twice.\");\n            }\n            // We cannot attempt to abort a transaction that has already been committed.\n            if (hasTxnState(\"committed\")) {\n                throw new Error(\"Cannot call abortTransaction after calling commitTransaction.\");\n            }\n            // If the session has no active transaction, raise an error.\n            if (hasTxnState(\"inactive\")) {\n                throw new Error(\"There is no active transaction to abort on this session.\");\n            }\n            // run abortTxn command\n            return endTransaction(\"abortTransaction\", driverSession);\n        }"},"getTxnWriteConcern":{"$code":"function getTxnWriteConcern(driverSession) {\n            // If a writeConcern is not specified from the default transaction options, it will be\n            // inherited from the session.\n            let writeConcern = undefined;\n            const sessionAwareClient = driverSession._getSessionAwareClient();\n            if (sessionAwareClient.getWriteConcern(driverSession) !== undefined) {\n                writeConcern = sessionAwareClient.getWriteConcern(driverSession);\n            }\n            if (_txnOptions.getTxnWriteConcern() !== undefined) {\n                writeConcern = _txnOptions.getTxnWriteConcern();\n            }\n            return writeConcern;\n        }"}},"_isExplicit":false,"getClient":{"$code":"function getClient() {\n                return client;\n            }"},"_getSessionAwareClient":{"$code":"function _getSessionAwareClient() {\n                return sessionAwareClient;\n            }"},"getOptions":{"$code":"function getOptions() {\n                return _options;\n            }"},"getSessionId":{"$code":"function getSessionId() {\n                if (!this._serverSession.hasOwnProperty(\"handle\")) {\n                    return null;\n                }\n                return this._serverSession.handle.getId();\n            }"},"getTxnNumber_forTesting":{"$code":"function getTxnNumber_forTesting() {\n                return this._serverSession.getTxnNumber();\n            }"},"getTxnWriteConcern_forTesting":{"$code":"function getTxnWriteConcern_forTesting() {\n                return this._serverSession.getTxnWriteConcern(this);\n            }"},"setTxnNumber_forTesting":{"$code":"function setTxnNumber_forTesting(newTxnNumber) {\n                this._serverSession.setTxnNumber_forTesting(newTxnNumber);\n            }"},"getOperationTime":{"$code":"function getOperationTime() {\n                return _operationTime;\n            }"},"advanceOperationTime":{"$code":"function advanceOperationTime(operationTime) {\n                if (!isNonNullObject(_operationTime) ||\n                    bsonWoCompare({_: operationTime}, {_: _operationTime}) > 0) {\n                    _operationTime = operationTime;\n                }\n            }"},"resetOperationTime_forTesting":{"$code":"function resetOperationTime_forTesting() {\n                _operationTime = undefined;\n            }"},"getClusterTime":{"$code":"function getClusterTime() {\n                return _clusterTime;\n            }"},"advanceClusterTime":{"$code":"function advanceClusterTime(clusterTime) {\n                if (!isNonNullObject(_clusterTime) ||\n                    bsonWoCompare({_: clusterTime.clusterTime}, {_: _clusterTime.clusterTime}) >\n                        0) {\n                    _clusterTime = clusterTime;\n                }\n            }"},"resetClusterTime_forTesting":{"$code":"function resetClusterTime_forTesting() {\n                _clusterTime = undefined;\n            }"},"getDatabase":{"$code":"function getDatabase(dbName) {\n                const db = client.getDB(dbName);\n                db._session = this;\n                return db;\n            }"},"hasEnded":{"$code":"function hasEnded() {\n                return _hasEnded;\n            }"},"endSession":{"$code":"function endSession() {\n                if (this._hasEnded) {\n                    return;\n                }\n\n                this._hasEnded = true;\n                implMethods.endSession(this._serverSession);\n            }"},"shellPrint":{"$code":"function() {\n                return this.toString();\n            }"},"tojson":{"$code":"function _tojson(...args) {\n                return tojson(this.getSessionId(), ...args);\n            }"},"toString":{"$code":"function toString() {\n                const sessionId = this.getSessionId();\n                if (sessionId === null) {\n                    return \"dummy session\";\n                }\n                return \"session \" + tojson(sessionId);\n            }"},"startTransaction":{"$code":"function startTransaction(txnOptsObj = {}) {\n                this._serverSession.startTransaction(txnOptsObj);\n            }"},"startTransaction_forTesting":{"$code":"function startTransaction_forTesting(\n                txnOptsObj = {}, {ignoreActiveTxn: ignoreActiveTxn = false} = {}) {\n                this._serverSession.startTransaction(txnOptsObj, ignoreActiveTxn);\n            }"},"commitTransaction":{"$code":"function commitTransaction() {\n                assert.commandWorked(this._serverSession.commitTransaction(this));\n            }"},"abortTransaction":{"$code":"function abortTransaction() {\n                // Intentionally ignore command result.\n                this._serverSession.abortTransaction(this);\n            }"},"commitTransaction_forTesting":{"$code":"function commitTransaction_forTesting() {\n                return this._serverSession.commitTransaction(this);\n            }"},"abortTransaction_forTesting":{"$code":"function abortTransaction_forTesting() {\n                return this._serverSession.abortTransaction(this);\n            }"},"processCommandResponse_forTesting":{"$code":"function processCommandResponse_forTesting(\n                res) {\n                processCommandResponse(this, client, res);\n            }"}}},"_shortName":"Surnames","_fullName":"lab3.Surnames"},"_ns":"lab3.Surnames","_query":{"PeoplesCount":{"$lte":4000.0}},"_fields":null,"_limit":0.0,"_skip":0.0,"_batchSize":0.0,"_options":0.0,"_cursor":null,"_numReturned":0.0,"_special":false}}
